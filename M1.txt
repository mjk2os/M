ALL PRACTICALS:
Aim:
1) Algorithm Analysis - Time Complexity Calculation: Write a Python or C++ program to find the time complexity of a given algorithm using step counting method. Analyze both recursive and non-recursive algorithms.

import time
def step_counter(func):
    def wrapper(*args, **kwargs):
        wrapper.steps = 0  # Reset steps
        return func(*args, **kwargs)
    return wrapper
class RecursiveCounter:
    def __init__(self):
        self.steps = 0
recursive_counter = RecursiveCounter()
@step_counter
def linear_search(arr, target):
    for i in range(len(arr)):
        linear_search.steps += 1  # Basic operation
        if arr[i] == target:
            return i
    return -1
def factorial(n):
    recursive_counter.steps += 1  # Basic operation
    if n <= 1:
        return 1
    return n * factorial(n - 1)
def fibonacci(n):
    recursive_counter.steps += 1  # Count the call
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
def analyze_function(func, *args, recursive=False):
    if recursive:
        recursive_counter.steps = 0
        start = time.time()
        result = func(*args)
        end = time.time()
        print(f"Result: {result}")
        print(f"Steps: {recursive_counter.steps}")
    else:
        func(*args)
        result = func(*args)
        print(f"Result: {result}")
        print(f"Steps: {func.steps}")
    print(f"Time taken: {(end - start) * 1000:.4f} ms" if recursive else "")
print("Non-recursive - Linear Search:")
analyze_function(linear_search, list(range(1000)), 999)
print("\nRecursive - Factorial:")
analyze_function(factorial, 10, recursive=True)
print("\nRecursive - Fibonacci:")
analyze_function(fibonacci, 10, recursive=True)



2) Implementing and Analyzing Sorting Algorithms: Implement Bubble Sort, Insertion Sort, and Merge Sort for a list of integers. Compare their time complexities for different input sizes (n=1000, 5000, 10000).

import random
import time
import matplotlib.pyplot as plt
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
def measure_time(sort_func, arr):
    start = time.time()
    sort_func(arr.copy())
    end = time.time()
    return (end - start) * 1000

sizes = [1000, 5000, 10000]
results = {'Bubble Sort': [], 'Insertion Sort': [], 'Merge Sort': []}
for size in sizes:
    data = [random.randint(1, 10000) for _ in range(size)]
    results['Bubble Sort'].append(measure_time(bubble_sort, data))
    results['Insertion Sort'].append(measure_time(insertion_sort, data))
    results['Merge Sort'].append(measure_time(merge_sort, data))
print("Timing Results (ms):")
for algo, times in results.items():
    print(f"{algo}: {dict(zip(sizes, times))}")
plt.figure(figsize=(10, 6))
for algo, times in results.items():
    plt.plot(sizes, times, marker='o', label=algo)
plt.title("Sorting Algorithms Time Complexity")
plt.xlabel("Input Size (n)")
plt.ylabel("Time (ms)")
plt.legend()
plt.grid(True)
plt.show()

3) Singly Linked List Operations: Write a program to implement a Singly Linked List with the following operations: Insert at beginning Insert at end Insert at given position Delete from beginning Delete from end Search an element Display list 

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    # Insert at beginning
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    # Insert at end
    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    # Insert at given position (1-based index)
    def insert_at_position(self, data, position):
        if position < 1:
            print("Invalid position!")
            return
        new_node = Node(data)
        if position == 1:
            new_node.next = self.head
            self.head = new_node
            return
        current = self.head
        for _ in range(position - 2):
            if current is None:
                print("Position out of bounds!")
                return
            current = current.next
        if current is None:
            print("Position out of bounds!")
            return
        new_node.next = current.next
        current.next = new_node

    # Delete from beginning
    def delete_from_beginning(self):
        if self.head is None:
            print("List is empty.")
            return
        self.head = self.head.next

    # Delete from end
    def delete_from_end(self):
        if self.head is None:
            print("List is empty.")
            return
        if self.head.next is None:
            self.head = None
            return
        current = self.head
        while current.next.next:
            current = current.next
        current.next = None

    # Search an element
    def search(self, target):
        current = self.head
        position = 1
        while current:
            if current.data == target:
                return position
            current = current.next
            position += 1
        return -1

    # Display list
    def display(self):
        current = self.head
        if not current:
            print("List is empty.")
            return
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Example Usage
if __name__ == "__main__":
    ll = SinglyLinkedList()
    ll.insert_at_end(10)
    ll.insert_at_beginning(5)
    ll.insert_at_end(15)
    ll.insert_at_position(12, 3)
    ll.display()  # Expected: 5 -> 10 -> 12 -> 15 -> None

    ll.delete_from_beginning()
    ll.display()  # Expected: 10 -> 12 -> 15 -> None

    ll.delete_from_end()
    ll.display()  # Expected: 10 -> 12 -> None

    pos = ll.search(12)
    print(f"Element 12 found at position: {pos}")  # Expected: 2

    pos = ll.search(99)
    print(f"Element 99 found at position: {pos}")  # Expected: -1

4) Circular Linked List Operations: Implement a Circular Linked List and demonstrate Insertion and Deletion operations at various positions. 

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.tail = None  # We keep track of the last node for easy circular linking

    # Display the list
    def display(self):
        if not self.tail:
            print("List is empty.")
            return
        current = self.tail.next
        while True:
            print(current.data, end=" -> ")
            current = current.next
            if current == self.tail.next:
                break
        print("(head)")

    # Insert at beginning
    def insert_at_beginning(self, data):
        new_node = Node(data)
        if not self.tail:
            self.tail = new_node
            self.tail.next = new_node
        else:
            new_node.next = self.tail.next
            self.tail.next = new_node

    # Insert at end
    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.tail:
            self.tail = new_node
            self.tail.next = new_node
        else:
            new_node.next = self.tail.next
            self.tail.next = new_node
            self.tail = new_node

    # Insert at a specific position (1-based index)
    def insert_at_position(self, data, pos):
        if pos < 1:
            print("Invalid position.")
            return
        if pos == 1:
            self.insert_at_beginning(data)
            return
        new_node = Node(data)
        current = self.tail.next
        for _ in range(pos - 2):
            current = current.next
            if current == self.tail.next:
                print("Position out of bounds.")
                return
        new_node.next = current.next
        current.next = new_node
        if current == self.tail:
            self.tail = new_node

    # Delete from beginning
    def delete_from_beginning(self):
        if not self.tail:
            print("List is empty.")
            return
        head = self.tail.next
        if self.tail == head:
            self.tail = None
        else:
            self.tail.next = head.next

    # Delete from end
    def delete_from_end(self):
        if not self.tail:
            print("List is empty.")
            return
        current = self.tail.next
        if self.tail == current:
            self.tail = None
            return
        while current.next != self.tail:
            current = current.next
        current.next = self.tail.next
        self.tail = current

    # Delete from a specific position (1-based index)
    def delete_from_position(self, pos):
        if not self.tail:
            print("List is empty.")
            return
        if pos == 1:
            self.delete_from_beginning()
            return
        current = self.tail.next
        for _ in range(pos - 2):
            current = current.next
            if current == self.tail:
                print("Position out of bounds.")
                return
        temp = current.next
        current.next = temp.next
        if temp == self.tail:
            self.tail = current

# Example usage
if __name__ == "__main__":
    cll = CircularLinkedList()
    cll.insert_at_end(10)
    cll.insert_at_beginning(5)
    cll.insert_at_end(20)
    cll.insert_at_position(15, 3)
    cll.display()  # 5 -> 10 -> 15 -> 20 -> (head)

    cll.delete_from_beginning()
    cll.display()  # 10 -> 15 -> 20 -> (head)

    cll.delete_from_end()
    cll.display()  # 10 -> 15 -> (head)

    cll.delete_from_position(2)
    cll.display()  # 10 -> (head)

5)  Stack using Linked List and Array: Implement a Stack ADT using 
both: Arrays Singly Linked List Compare and explain the advantages/disadvantages of each. 

# 1. Stack using Array
class StackArray:
    def __init__(self, capacity=100):
        self.stack = []
        self.capacity = capacity

    def push(self, data):
        if len(self.stack) >= self.capacity:
            print("Stack Overflow!")
            return
        self.stack.append(data)

    def pop(self):
        if self.is_empty():
            print("Stack Underflow!")
            return None
        return self.stack.pop()

    def peek(self):
        return self.stack[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.stack) == 0

    def display(self):
        print("Stack (top to bottom):", self.stack[::-1])


# 2. Stack using Singly Linked List
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class StackLinkedList:
    def __init__(self):
        self.top = None

    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top
        self.top = new_node

    def pop(self):
        if self.is_empty():
            print("Stack Underflow!")
            return None
        popped = self.top
        self.top = self.top.next
        return popped.data

    def peek(self):
        return self.top.data if not self.is_empty() else None

    def is_empty(self):
        return self.top is None

    def display(self):
        current = self.top
        print("Stack (top to bottom):", end=" ")
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")


# === Your Desired Output Code ===
sa = StackArray()
sa.push(10)
sa.push(20)

sl = StackLinkedList()
sl.push(30)
sl.push(40)

print("Array Stack Top:", sa.peek())
print("Linked List Stack Top:", sl.peek())


6) Balanced Parentheses Checker using Stack: Write a program to 
check if a given expression has balanced parentheses using a Stack

\def is_balanced(expression):
    stack = []
    matching = {')': '(', '}': '{', ']': '['}
    for char in expression:
        if char in '([{':
            stack.append(char)
        elif char in ')]}':
            if not stack or stack[-1] != matching[char]:
                return False
            stack.pop()
    return len(stack) == 0

# Example Usage
if __name__ == "__main__":
    expressions = [
        "(a+b)",
        "((a+b)*c)",
        "{a+(b*c)-[d/e]}",
        "[({})]",
        "(a+b]",
        "((a+b)",
        "(a+b))"
    ]
    for exp in expressions:
        result = "Balanced" if is_balanced(exp) else "Not Balanced"
        print(f"{exp} --> {result}")

7) Queue using Array and Linked List: Implement a Queue ADT using both. Array (Circular Queue) Linked List Compare memory usage and performance for different sizes of input.

# Circular Queue using Array
class CircularQueueArray:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = self.rear = -1

    def is_full(self):
        return (self.rear + 1) % self.capacity == self.front

    def is_empty(self):
        return self.front == -1

    def enqueue(self, data):
        if self.is_full():
            return
        if self.is_empty():
            self.front = 0
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = data

    def get_front(self):
        if self.is_empty():
            return None
        return self.queue[self.front]


# Linked List Queue
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None

    def is_empty(self):
        return self.front is None

    def enqueue(self, data):
        new_node = Node(data)
        if self.rear is None:
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node

    def get_front(self):
        if self.is_empty():
            return None
        return self.front.data


# ===================
# Create objects and enqueue data
# ===================

# Circular Queue
cq = CircularQueueArray(5)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)

# Linked List Queue
llq = LinkedListQueue()
llq.enqueue(10)
llq.enqueue(20)
llq.enqueue(30)

# Print front elements
print("CircularQueue Front:", cq.get_front())
print("LinkedListQueue Front:", llq.get_front())

8) Binary Tree Traversals: Write a program to create a Binary Tree. Implement Preorder, Inorder,and Postorder Traversals (Recursive and Iterative using Stacks.

class Node: 
    def __init__(self, data): 
        self.data = data 
        self.left = None 
        self.right = None 

class BinaryTree: 
    def __init__(self): 
        self.root = None 

    # ------------ Recursive Traversals ------------ 
    def preorder_recursive(self, node): 
        if node: 
            print(node.data, end=' ') 
            self.preorder_recursive(node.left) 
            self.preorder_recursive(node.right) 

    def inorder_recursive(self, node): 
        if node: 
            self.inorder_recursive(node.left) 
            print(node.data, end=' ') 
            self.inorder_recursive(node.right) 

    def postorder_recursive(self, node):
        if node: 
            self.postorder_recursive(node.left)
            self.postorder_recursive(node.right)
            print(node.data, end=' ') 

    # ------------ Iterative Traversals ------------ 
    def inorder_iterative(self): 
        stack = [] 
        current = self.root 
        while stack or current: 
            if current: 
                stack.append(current) 
                current = current.left 
            else: 
                current = stack.pop() 
                print(current.data, end=' ') 
                current = current.right 

    def preorder_iterative(self): 
        if not self.root: 
            return 
        stack = [self.root] 
        while stack: 
            current = stack.pop() 
            print(current.data, end=' ') 
            if current.right: 
                stack.append(current.right) 
            if current.left: 
                stack.append(current.left) 

    def postorder_iterative(self): 
        if not self.root: 
            return 
        stack1 = [self.root]
        stack2 = [] 
        while stack1: 
            node = stack1.pop() 
            stack2.append(node) 
            if node.left: 
                stack1.append(node.left) 
            if node.right: 
                stack1.append(node.right) 
        while stack2: 
            print(stack2.pop().data, end=' ') 


if __name__ == "__main__": 
    # Build the binary tree manually 
    tree = BinaryTree() 
    tree.root = Node(1) 
    tree.root.left = Node(2) 
    tree.root.right = Node(3) 
    tree.root.left.left = Node(4) 
    tree.root.left.right = Node(5) 
    tree.root.right.left = Node(6) 
    tree.root.right.right = Node(7) 

    print("Recursive Preorder:") 
    tree.preorder_recursive(tree.root) 

    print("\nRecursive Inorder:") 
    tree.inorder_recursive(tree.root) 

    print("\nRecursive Postorder:") 
    tree.postorder_recursive(tree.root) 

    print("\n\nIterative Preorder:") 
    tree.preorder_iterative() 

    print("\nIterative Inorder:") 
    tree.inorder_iterative() 

    print("\nIterative Postorder:") 
    tree.postorder_iterative()

9) Expression Tree Construction: Construct an Expression Tree for a given postfix expression and evaluate the expression using the tree.

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class ExpressionTree:
    def __init__(self):
        self.root = None
        
    def is_operator(self, c):
            return c in "+-*/"
        
    def construct_tree(self, postfix):

        stack = []
        for token in postfix.split():
            if not self.is_operator(token):
                stack.append(Node(token))
            else:
                right = stack.pop()
                left = stack.pop()
                node = Node(token)
                node.left = left
                node.right = right
                stack.append(node)
                self.root = stack[-1]
    def evaluate(self, node=None):
        if node is None:
            node = self.root
        if not self.is_operator(node.value):
            return float(node.value)
        left_val = self.evaluate(node.left)
        right_val = self.evaluate(node.right)

        if node.value == '+':
            return left_val + right_val
        elif node.value == '-':
            return left_val - right_val
        elif node.value == '*':
            return left_val * right_val
        elif node.value == '/':
            return left_val / right_val
        
    def inorder(self, node=None):
        if node is None:
            node = self.root
        if node.left:
            print("(", end=" ")
            self.inorder(node.left)
        print(node.value, end=" ")
        if node.right:
            self.inorder(node.right)
            print(")", end=" ")
                
# Example usage
if __name__ == "__main__":
    postfix_expr = "3 4 + 2 * 7 /" # equivalent to ((3 + 4) * 2) / 7
    tree = ExpressionTree()
    tree.construct_tree(postfix_expr)

    print("Inorder (Infix) Expression:")
    tree.inorder()

    print("\n\nEvaluated Result:")
    print(tree.evaluate())

10)  AVL Tree Implementation: Implement an AVL Tree with insertion and rotation operations. Display the tree after each insertion.

class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1 # Height of node 


class AVLTree:
    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def right_rotate(self, y):
        x = y.left
        T2 = x.right

        # Perform rotation
        x.right = y
        y.left = T2

        # Update heights
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))

        return x

    def left_rotate(self, x):
        y = x.right
        T2 = y.left

        # Perform rotation
        y.left = x
        x.right = T2

        # Update heights
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))

        return y

    def insert(self, root, key):
        # Normal BST insert
        if not root:
            return Node(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        # Update height
        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))

        # Get balance factor
        balance = self.get_balance(root)

        # Balance the tree
        # Left Left Case
        if balance > 1 and key < root.left.key:
            return self.right_rotate(root)

        # Right Right Case
        if balance < -1 and key > root.right.key:
            return self.left_rotate(root)

        # Left Right Case
        if balance > 1 and key > root.left.key:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)

        # Right Left Case
        if balance < -1 and key < root.right.key:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)

        return root

    def inorder(self, root):
        if root:
            self.inorder(root.left)
            balance = self.get_balance(root)
            print(f"{root.key}(h={root.height}, bf={balance})", end=" ")
            self.inorder(root.right)

    def display(self, root):
        print("Inorder traversal with (height, balance factor):")
        self.inorder(root)
        print("\n") 

if __name__ == "__main__":
    avl = AVLTree()
    root = None
    values = [10, 20, 30, 40, 50, 25]

    for val in values:
        print(f"Inserting {val}:")
        root = avl.insert(root, val)
        avl.display(root)

11) Graph Representation and Traversals: Create a Graph using an Adjacency List and Adjacency Matrix. Implement Depth First Search (DFS) and Breadth First Search (BFS) for the graph.

from collections import defaultdict, deque
class GraphAdjList:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        # For undirected graph, uncomment the next line
        # self.graph[v].append(u)

    def dfs_util(self, v, visited):
        print(v, end=' ')
        visited[v] = True
        for neighbor in self.graph[v]:
            if not visited[neighbor]:
                self.dfs_util(neighbor, visited)

    def dfs(self, start):
        visited = [False] * self.V
        print("DFS (Adjacency List):", end=' ')
        self.dfs_util(start, visited)
        print()

    def bfs(self, start):
        visited = [False] * self.V
        queue = deque([start])
        visited[start] = True
        print("BFS (Adjacency List):", end=' ')
        while queue:
            v = queue.popleft()
            print(v, end=' ')
            for neighbor in self.graph[v]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        print() 

class GraphAdjMatrix:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]

    def add_edge(self, u, v):
        self.graph[u][v] = 1
        # For undirected graph, uncomment the next line
        # self.graph[v][u] = 1

    def dfs_util(self, v, visited):
        print(v, end=' ')
        visited[v] = True
        for i in range(self.V):
            if self.graph[v][i] == 1 and not visited[i]:
                self.dfs_util(i, visited)

    def dfs(self, start):
        visited = [False] * self.V
        print("DFS (Adjacency Matrix):", end=' ')
        self.dfs_util(start, visited)
    print()

    def bfs(self, start):
        visited = [False] * self.V
        queue = deque([start])
        visited[start] = True
        print("BFS (Adjacency Matrix):", end=' ')
        while queue:
            v = queue.popleft()
            print(v, end=' ')
            for i in range(self.V):
                if self.graph[v][i] == 1 and not visited[i]:
                    visited[i] = True
                    queue.append(i)
        print()

if __name__ == "__main__":
    vertices = 5
    edges = [
        (0, 1), (0, 2), (1, 2),
        (2, 0), (2, 3), (3, 3),
        (3, 4)
        ]
    print("=== Using Adjacency List ===")
    g_list = GraphAdjList(vertices)
    for u, v in edges:
        g_list.add_edge(u, v)
        g_list.dfs(2)
        g_list.bfs(2)

    print("\n=== Using Adjacency Matrix ===")
    g_matrix = GraphAdjMatrix(vertices)
    for u, v in edges:
        g_matrix.add_edge(u, v) 

    g_matrix.dfs(2)
    g_matrix.bfs(2)


12) Shortest Path using Dijkstra's Algorithm: Implement Dijkstra’s Algorithm to find the shortest path from a source node to all other nodes in a weighted graph.

import heapq
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj = {i: [] for i in range(vertices)} # adjacency list: node -> [(neighbor, weight), ...]

    def add_edge(self, u, v, w):
        self.adj[u].append((v, w))
        # For undirected graph, uncomment the next line
        # self.adj[v].append((u, w))

    def dijkstra(self, src):
        dist = [float('inf')] * self.V
        dist[src] = 0
        min_heap = [(0, src)] # (distance, vertex)

        while min_heap:
            current_dist, u = heapq.heappop(min_heap)

            # Skip if this is an outdated entry
            if current_dist > dist[u]:
                continue
            for neighbor, weight in self.adj[u]:
                distance = current_dist + weight
                if distance < dist[neighbor]:
                    dist[neighbor] = distance
                    heapq.heappush(min_heap, (distance, neighbor))

        return dist

    
if __name__ == "__main__":
    g = Graph(5)
    g.add_edge(0, 1, 9)
    g.add_edge(0, 2, 6)
    g.add_edge(0, 3, 5)
    g.add_edge(0, 4, 3)
    g.add_edge(2, 1, 2)
    g.add_edge(2, 3, 4)

    source = 0
    distances = g.dijkstra(source)


    print(f"Shortest distances from node {source}:")
    for i,d in enumerate(distances):
        print(f"Node (i) : (d)")

13) Minimum Spanning Tree using Prim’s and Kruskal’s Algorithms: Write a program to compute MST (Minimum Spanning Tree) for a connected graph using Prim’s Algorithm and Kruskal’s Algorithm.

import sys
def prim_mst(graph):
    V = len(graph)
    key = [sys.maxsize] * V  # Initialize keys as infinite
    parent = [None] * V      # Array to store constructed MST
    key[0] = 0               # Start from vertex 0
    mstSet = [False] * V

    for _ in range(V):
        # Pick the minimum key vertex from the set of vertices not yet included in MST
        u = min((k for k in range(V) if not mstSet[k]), key=lambda x: key[x])
        mstSet[u] = True

        # Update key and parent index of the adjacent vertices
        for v in range(V):
            if graph[u][v] > 0 and not mstSet[v] and key[v] > graph[u][v]:
                key[v] = graph[u][v]
                parent[v] = u

    # Print the constructed MST
    print("Prim's MST edges (u - v) and weights:")
    for i in range(1, V):
        print(f"{parent[i]} - {i} : {graph[i][parent[i]]}")

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            if self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            elif self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1
            return True
        return False

def kruskal_mst(edges, V):
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(V)
    mst = []
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
            if len(mst) == V - 1:
                break
    print("Kruskal's MST edges (u - v) and weights:")
    for u, v, w in mst:
        print(f"{u} - {v} : {w}")

if __name__ == "__main__":
    # Graph represented as adjacency matrix for Prim's
    graph = [
        [0, 2, 0, 6, 0],
        [2, 0, 3, 8, 5],
        [0, 3, 0, 0, 7],
        [6, 8, 0, 0, 9],
        [0, 5, 7, 9, 0]
    ]

    print("Using Prim's Algorithm:")
    prim_mst(graph)

    print("\nUsing Kruskal's Algorithm:")
    # Graph edges for Kruskal's (u, v, weight)
    edges = [
        (0, 1, 2),
        (0, 3, 6),
        (1, 2, 3),
        (1, 3, 8),
        (1, 4, 5),
        (2, 4, 7),
        (3, 4, 9)
    ]
    V = 5
    kruskal_mst(edges, V)

14) Sorting Algorithm Performance Comparison: Implement QuickSort and Heap Sort for large arrays (n = 10000) and compare their performance using the time library.

import random
import time
# Quick Sort implementation
def quick_sort(arr):
    def _quick_sort(items, low, high):
        if low < high:
            pivot_index = partition(items, low, high)
            _quick_sort(items, low, pivot_index - 1)
            _quick_sort(items, pivot_index + 1, high)

    def partition(items, low, high):
        pivot = items[high]
        i = low - 1
        for j in range(low, high):
            if items[j] <= pivot:
                i += 1
                items[i], items[j] = items[j], items[i]
        items[i + 1], items[high] = items[high], items[i + 1]
        return i + 1

    _quick_sort(arr, 0, len(arr) - 1)

# Heap Sort implementation
def heap_sort(arr):
    def heapify(items, n, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and items[left] > items[largest]:
            largest = left
        if right < n and items[right] > items[largest]:
            largest = right

        if largest != i:
            items[i], items[largest] = items[largest], items[i]
            heapify(items, n, largest)

    n = len(arr)
    # Build max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements one by one
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)

# Main code to test and compare performance
if __name__ == "__main__":
    n = 10000
    arr1 = [random.randint(1, 100000) for _ in range(n)]
    arr2 = arr1.copy()

    start = time.time()
    quick_sort(arr1)
    quick_sort_time = time.time() - start

    start = time.time()
    heap_sort(arr2)
    heap_sort_time = time.time() - start

    print(f"Quick Sort Time for n={n}: {quick_sort_time:.6f} seconds")
    print(f"Heap Sort Time for n={n}: {heap_sort_time:.6f} seconds")

    # Optional: Verify both sorted arrays are equal
    assert arr1 == arr2, "Sorting results do not match!"

15) Searching Techniques Comparison Implement:Linear Search Binary Search Interpolation Search

def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1

def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

def interpolation_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high and target >= arr[low] and target <= arr[high]:
        if low == high:
            if arr[low] == target:
                return low
            return -1
       
        # Probing the position with keeping uniform distribution in mind
        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])
       
        if arr[pos] == target:
            return pos
        elif arr[pos] < target:
            low = pos + 1
        else:
            high = pos - 1
    return -1

if __name__ == "__main__":
    arr = [2, 4, 7, 11, 18, 23, 37, 56, 72, 91]
    target = 37

    print("Linear Search:")
    index = linear_search(arr, target)
    print(f"Element {target} found at index: {index}" if index != -1 else "Not found")

    print("Binary Search:")
    index = binary_search(arr, target)
    print(f"Element {target} found at index: {index}" if index != -1 else "Not found")

    print("Interpolation Search:")
    index = interpolation_search(arr, target)
    print(f"Element {target} found at index: {index}" if index != -1 else "Not found")
